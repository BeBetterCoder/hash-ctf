# DEFCON CTF 31 Quals

A great game experience with StrawHat

First time to Participate DC, with less cryptography element but also make me interesting.

It's wonderful to solve a problem with players from different directions

![](https://picture-1311455354.cos.ap-shanghai.myqcloud.com/image-20230531141830826.png)

Finally, just to record some crypto part.

## IFUCKUP

Simulate the ASLR protect. The stack part is controled by a prng WELL512.

If we can recover the state of prng, the problem is easy. guessed :)

[WELL Algorithm](https://en.wikipedia.org/wiki/Well_equidistributed_long-period_linear)

![](https://picture-1311455354.cos.ap-shanghai.myqcloud.com/image-20230531172459990.png)

The option in well512 is all linear, so we can use a matrix to replace it. We can easily verify this.

```python
import random


class Well512(object):
    def __init__(self, state, idx=0):
        assert len(state) == 16
        self.idx = idx
        self.state = [x for x in state]

    def gen(self):
        idx = self.idx
        state = self.state

        a = state[idx]
        c = state[(idx + 13) & 0xF]
        z1 = a ^^ (a << 16) ^^ c ^^ (c << 15)
        z1 &= 0xffffffff

        a = state[(idx + 9) & 0xF]
        z2 = a ^^ (a>>11)
        z2 &= 0xffffffff

        state[idx] = (z1 ^^ z2) & 0xffffffff
        tval = state[idx]

        idx = (idx + 15) & 0xf
        self.idx = idx

        state[idx] ^^= ((state[idx] << 2) ^^ (z1 << 18) ^^ z2 ^^ (z2 << 28) ^^ ((tval << 5)) &  0xda442d24) & 0xffffffff

        return state[idx]


def s2b(state):
    bit = []
    for _ in range(16):
        bit.extend(list(map(int, bin(state[_])[2:].rjust(32, '0'))))
    return bit

def b2s(stream):
    num = []
    for i in range(0, 512, 32):
        n = 0
        for _ in range(32):
            n = 2 * n
            n += int(stream[i:i+32][_])
        num.append(n)
    return num


def i32tovec(num):
  return list(map(int, bin(num)[2:].rjust(32, '0')))


for idx in range(16):
    state1 = [random.randint(0, 2**32-1) for _ in range(16)]
    state2 = [random.randint(0, 2**32-1) for _ in range(16)]
    v1 = Well512(state1, 1)
    v2 = Well512(state2, 1)
    state3 = b2s(list(vector(Zmod(2), s2b(state1))+vector(Zmod(2), s2b(state2))))
    v3 = Well512(state3, 1)
    n1 = []
    n2 = []
    n3 = []

    check = vector(Zmod(2), i32tovec(v1.gen()))+vector(Zmod(2), i32tovec(v2.gen()))
    assert check == vector(Zmod(2), i32tovec(v3.gen()))
    
    n1.extend(v1.state)
    n2.extend(v2.state)
    n3.extend(v3.state)

    check1 = vector(Zmod(2), s2b(n1))+vector(Zmod(2), s2b(n2))
    check2 = vector(Zmod(2), s2b(n3))
    assert check1 == check2
```

![](https://picture-1311455354.cos.ap-shanghai.myqcloud.com/image-20230531174133782.png)

Contruct the matrix $M_i,L_i$ using $state_i = 2^i$ to get the matrix's $i^{th}$ column

In this problem, we can burst the interval between the number generated by Well1, while using the next data to distinguish the true state. The data is not consecutive, but can chose the corresponding row to construct the final matrix.

The final matrix may not full rank, but still have a high rank, so we just need to get the kernel and burst the small coefficient.

```python
import random
from tqdm import tqdm


class Well512(object):
    def __init__(self, state, idx=0):
        assert len(state) == 16
        self.idx = idx
        self.state = [x for x in state]

    def gen(self):
        idx = self.idx
        state = self.state

        a = state[idx]
        c = state[(idx + 13) & 0xF]
        z1 = a ^^ (a << 16) ^^ c ^^ (c << 15)
        z1 &= 0xffffffff

        a = state[(idx + 9) & 0xF]
        z2 = a ^^ (a>>11)
        z2 &= 0xffffffff

        state[idx] = (z1 ^^ z2) & 0xffffffff
        tval = state[idx]

        idx = (idx + 15) & 0xf
        self.idx = idx

        state[idx] ^^= ((state[idx] << 2) ^^ (z1 << 18) ^^ z2 ^^ (z2 << 28) ^^ ((tval << 5)) &  0xda442d24) & 0xffffffff

        return state[idx]


def s2b(state):
    bit = []
    for _ in range(16):
        bit.extend(list(map(int, bin(state[_])[2:].rjust(32, '0'))))
    return bit


def b2s(stream):
    num = []
    for i in range(0, 512, 32):
        n = 0
        for _ in range(32):
            n = 2 * n
            n += int(stream[i:i+32][_])
        num.append(n)
    return num


def i32tovec(num):
  return list(map(int, bin(num)[2:].rjust(32, '0')))


def vectoi32(array):
  tp = 0
  for _ in range(32):
    tp *= 2
    tp += int(array[_])
  return tp


print("[+] construct matrix")
A = []
B = []

for idx in range(16):
    A_i = []
    hide = []
    for _ in range(512):
        test = b2s('0'*_+'1'+'0'*(511-_))
        well = Well512(test, (-idx)%16)
        hide.append(well.gen())
        A_i.append(s2b(well.state))
    A.append(A_i)

for idx in range(16):
    B_i = []
    for _ in range(512):
      test = b2s('0'*_+'1'+'0'*(511-_))
      well = Well512(test, (-idx)%16)
      B_i.append(i32tovec(well.gen()))
    B.append(B_i)

M1 = []
M2 = []
for _ in range(16):
    M1.append(matrix(Zmod(2), A[_]).T)
    M2.append(matrix(Zmod(2), B[_]).T)
print("[+] construct done")


def con_matrix(cache):
  for bp1 in tqdm(range(16)):
    for bp2 in tqdm(range(256)):
      M = []
      for _ in range(8):
        T = M2[(bp1+_)%16]
        if _>0:
          T1 = M1[bp1]
          for i in range(1, _):
            T1 = M1[(bp1+i)%16]*T1
          T = T*T1
        M.extend(list(T))
      for _ in range(8, 16):
        T = M2[(bp1+_+bp2)%16]
        T1 = M1[bp1]
        for i in range(1, _+bp2):
          T1 = M1[(bp1+i)%16]*T1
        T = T*T1
        M.extend(list(T))
      M = matrix(Zmod(2), M)
      cache.append(M)


def solve_filter(state, offset, check, head, idx):
  for i in range(16):
    well = Well512(state[i:]+state[:i], (-idx)%16)
    num = []
    hide = []
    for _ in range(16+offset):
      hide.append(well.gen())
    for _ in range(256+8):
      num.append(well.gen())
    for _ in range(8):
      if check[_] not in num:
        break
    else:
      well = Well512(state[i:]+state[:i], (-idx)%16)
      ck = []
      for _ in range(8):
        ck.append(well.gen())
      for _ in range(offset):
        hide.append(well.gen())
      for _ in range(8):
        ck.append(well.gen())
      if ck == head:
        return True, state[i:]+state[:i]


def PartI(idx, offset):
  r = [random.randint(0, 2**32-1) for _ in range(16)]
  well = Well512(r, (-idx)%16)
  num = []
  check_num = []
  hide = []
  for _ in range(8):
    num.append(well.gen())
  for _ in range(offset):
    hide.append(well.gen())
  for _ in range(8):
    num.append(well.gen())
  for _ in range(randint(0, 255)):
    hide.append(well.gen())
  for _ in range(8):
    check_num.append(well.gen())
  print("[+] Start Burp!")
  for ost in tqdm(range(256)):
    M = []
    for _ in range(8):
      T = M2[(_)%16]
      if _>0:
        T1 = M1[0]
        for i in range(1, _):
          T1 = M1[(i)%16]*T1
        T = T*T1
      M.extend(list(T))
    for _ in range(8, 16):
      T = M2[(_+ost)%16]
      T1 = M1[0]
      for i in range(1, _+ost):
        T1 = M1[(i)%16]*T1
      T = T*T1
      M.extend(list(T))
    M = matrix(Zmod(2), M)
    u = vector(Zmod(2), s2b(num))
    v = vector(Zmod(2), s2b(r))
    try:
      solve_basis = M.solve_right(u)
      ker = M.right_kernel().basis()
      if len(ker) == 0:
        sign = solve_filter(b2s(solve_basis), ost, check_num, num, idx)
        if sign:
          print("[+] Find solve!")
          print("my solve", ost, ":", sign[1])
          assert r == sign[1]
          return True
      else:
        for time in range(2**len(ker)):
          bit = time
          j = 0
          solve = solve_basis
          while bit:
            if bit&1:
              solve += ker[j]
              bit = bit>>1
              j += 1
              sign = solve_filter(b2s(solve), ost, check_num, num, idx)
              if sign:
                print("[+] Find solve!")
                print("my solve", ost, ":", sign[1])
                assert r == sign[1]
                return True
            else:
              bit = bit>>1
              j += 1
    except Exception as e:
      continue


def PartII(idx):
  r = [random.randint(0, 2**32-1) for _ in range(16)]
  well = Well512(r, (-idx)%16)
  num = []
  hide = []
  for round in range(9):
    for _ in range(8):
      num.append(well.gen()>>24)
    for _ in range(3):
      hide.append(well.gen())
  M = []
  for round in range(9):
    for _ in range(8):
      T = M2[(idx+_+round*11)%16]
      if _+round*11>0:
        T1 = M1[idx]
        for i in range(1, round*11+_):
          T1 = M1[(idx+i)%16]*T1
        T = T*T1
      M.extend(list(T)[:8])
  M = matrix(Zmod(2), M)
  u = []
  for _ in range(8*9):
    u.extend(list(map(int, bin(num[_])[2:].rjust(8, '0'))))
  u = vector(Zmod(2), u)
  solve = b2s(M.solve_right(u))
  assert r == solve
  return solve
  

r1 = randint(0, 15)
r2 = randint(0, 255)
PartI(r1, r2)
PartII(r1)
```

## Seedling

```c
setvbuf(stdout, 0LL, 2, 0LL);
  if ( argc <= 1 )
  {
    puts("./verify <key> [binary] [hashes]");
    exit(1);
  }
```

We need to upload a binary and generate it's hash without key.

![image-20230531182808827](../AppData/Roaming/Typora/typora-user-images/image-20230531182808827.png)

Sha256 is Merkle–Damgård construction, we can use length extension attack to pad some data following the original data like shellcode.

```python
import os
import random

K = [
    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
    0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
    0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
    0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
    0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2
]

def generate_hash(message, debug = 0, init = []) -> bytearray:

    if isinstance(message, str):
        message = bytearray(message, 'ascii')
    elif isinstance(message, bytes):
        message = bytearray(message)
    elif not isinstance(message, bytearray):
        raise TypeError

    # Parsing
    blocks = [] # contains 512-bit chunks of message
    for i in range(0, len(message), 64): # 64 bytes is 512 bits
        blocks.append(message[i:i+64])

    # Setting Initial Hash Value
    if debug == 0:
        h0 = 0x6a09e667
        h1 = 0xbb67ae85
        h2 = 0x3c6ef372
        h3 = 0xa54ff53a
        h5 = 0x9b05688c
        h4 = 0x510e527f
        h6 = 0x1f83d9ab
        h7 = 0x5be0cd19
    else:
        h0, h1, h2, h3, h4, h5, h6, h7 = init


    # SHA-256 Hash Computation
    for message_block in blocks:
        # Prepare message schedule
        message_schedule = []
        for t in range(0, 64):
            if t <= 15:
                # adds the t'th 32 bit word of the block,
                # starting from leftmost word
                # 4 bytes at a time
                message_schedule.append(bytes(message_block[t*4:(t*4)+4]))
            else:
                term1 = _sigma1(int.from_bytes(message_schedule[t-2], 'big'))
                term2 = int.from_bytes(message_schedule[t-7], 'big')
                term3 = _sigma0(int.from_bytes(message_schedule[t-15], 'big'))
                term4 = int.from_bytes(message_schedule[t-16], 'big')

                # append a 4-byte byte object
                schedule = ((term1 + term2 + term3 + term4) % 2**32).to_bytes(4, 'big')
                message_schedule.append(schedule)

        assert len(message_schedule) == 64


        # Initialize working variables
        a = h0
        b = h1
        c = h2
        d = h3
        e = h4
        f = h5
        g = h6
        h = h7


        # Iterate for t=0 to 63
        for t in range(64):
            t1 = ((h + _capsigma1(e) + _ch(e, f, g) + K[t] +
                   int.from_bytes(message_schedule[t], 'big')) % 2**32)

            t2 = (_capsigma0(a) + _maj(a, b, c)) % 2**32

            h = g
            g = f
            f = e
            e = (d + t1) % 2**32
            d = c
            c = b
            b = a
            a = (t1 + t2) % 2**32

        # Compute intermediate hash value
        h0 = (h0 + a) % 2**32
        h1 = (h1 + b) % 2**32
        h2 = (h2 + c) % 2**32
        h3 = (h3 + d) % 2**32
        h4 = (h4 + e) % 2**32
        h5 = (h5 + f) % 2**32
        h6 = (h6 + g) % 2**32
        h7 = (h7 + h) % 2**32


    return ((h0).to_bytes(4, 'big') + (h1).to_bytes(4, 'big') +
            (h2).to_bytes(4, 'big') + (h3).to_bytes(4, 'big') +
            (h4).to_bytes(4, 'big') + (h5).to_bytes(4, 'big') +
            (h6).to_bytes(4, 'big') + (h7).to_bytes(4, 'big'))

def _sigma0(num: int):
    """As defined in the specification."""
    num = (_rotate_right(num, 7) ^
           _rotate_right(num, 18) ^
           (num >> 3))
    return num

def _sigma1(num: int):
    """As defined in the specification."""
    num = (_rotate_right(num, 17) ^
           _rotate_right(num, 19) ^
           (num >> 10))
    return num

def _capsigma0(num: int):
    """As defined in the specification."""
    num = (_rotate_right(num, 2) ^
           _rotate_right(num, 13) ^
           _rotate_right(num, 22))
    return num

def _capsigma1(num: int):
    """As defined in the specification."""
    num = (_rotate_right(num, 6) ^
           _rotate_right(num, 11) ^
           _rotate_right(num, 25))
    return num

def _ch(x: int, y: int, z: int):
    """As defined in the specification."""
    return (x & y) ^ (~x & z)

def _maj(x: int, y: int, z: int):
    """As defined in the specification."""
    return (x & y) ^ (x & z) ^ (y & z)

def _rotate_right(num: int, shift: int, size: int = 32):
    """Rotate an integer right."""
    return (num >> shift) | (num << size - shift)



def Pad(message,k):
    message = bytearray(message)
    length = len(message) * 8+512*k  # len(message) is number of BYTES!!!

    message.append(0x80)
    while (len(message) * 8 + 64) % 512 != 0:
        message.append(0x00)

    message += length.to_bytes(8, 'big')  # pad to 8 bytes or 64 bits

    assert (len(message) * 8) % 512 == 0, "Padding did not complete properly!"

    return message


def spl_hex(a):
    res = []
    for i in range(8):
        res.append(int(a[i*8:(i+1)*8], 16))
    return res

from hashlib import sha256

def test():
    for _ in range(1024):
        length = random.randint(0,512)
        mes = os.urandom(length)
        add = b'addmessage'
        h = sha256(mes).hexdigest()
        num = spl_hex(h)
        my_hash = generate_hash(Pad(add, (length % 64) // 56 + length // 64 + 1), 1, num).hex()
        real_hash = sha256(Pad(mes, 0)+add).hexdigest()
        assert my_hash == real_hash

#sha(secret+msg) -> sha(secret+msg+content)
test()
l_array = [56] #len(secret+msg)
h_array = ['b35439a4ac6f0948b6d6f9e3c6af0f5f590ce20f1bde7090ef7970686ec6738a'] #sha(secret+msg)
add_array = [b'hash'] #content suffix
num = 1
for _ in range(num):
    h = h_array[_]
    add = add_array[_]
    l = l_array[_]
    num = spl_hex(h)
    my_hash = generate_hash(Pad(add, (l % 64) // 56 + l // 64 + 1), 1, num).hex()
    print(my_hash)
```

Btw, all this things can be done with HashPump and I I plan to write one. It's helpful to learn the detail of hash function.
