# Strange_CRT

- [attachment](https://github.com/hash-hash/crypto/blob/main/tqlctf/hardrsa.py)
- [paper](https://link.springer.com/chapter/10.1007/3-540-45708-9_16)

这和TQLCTF那道差不大多，参数我好像改了下，应该是比之前的要紧一点

试了一下发现TQL那道可以直接照搬过来打，算了下界也是满足的

May那篇论文是采取按模p下构造shift多项式

$ed_p+(k-1)=0(mod~p)$

记 $f=ex-y$ 含有根 $(d_p,-(k-1))$

构造 $h_{i,j}=N^{max(0,m-i)}x^jf^i$

为方便格的构造我们取 $j=n-1-i$ ，对这种方式的大小进行一下估计

$det(L)=N^{\frac{m(m+1)}{2}}(XY)^{\frac{n(n+1)}{2}}$ < $N^{\frac{m(m+1)}{2}+(\beta+2\theta)\frac{n(n+1)}{2}}$

为了使最终规约后的系数满足howgrave约束需要有 $\frac{m(m+1)}{2}+(2\theta+\beta)\frac{n(n+1)}{2}-(1-\beta)mn≤0$

论文中有提到 $m=(1-\beta)n$ 时是一个较优的取值

最终给出结论只需系数满足 $3\beta-\beta^2+2\theta≤1$ 即可利用上述方式求解

- exp

```python
import gmpy2
e= 7416229890364012096238738128277321301908842037351918926321669172812949802970954320807051730418429640930294163194178722409412050396900823825176971085953727729972188588741350220965748255471642119854209098682490581574621930301283606567360162839806265935540833630905902641341470793620440769987234366602545942796435229968444073251908843752603301579408254898919643221680719248752583171594268904067361138241600198855519961139751211416248924734817620731364316215891131479082190491193603603945078681058641276135261422530384401040331992745170946846542893368433128335474640997451603271123266496509538320810962993580794342130613
N= 8221635024713054585304053539021905136743205412187291398885312502399146054201409559822858046345415108219532665593701220184175280226302483758204213943938619030311190539750692907088281851435337042403928414387445811611057535114894557687354207543271029179468281847184642639824707923783483687056843044358418219098480533592879954565812937773603277605901559304277542919322287339549794597102400876949557186130060858645071617461414535802227114649852327725102536671000824327009691209080753758211062334549803396217773495637438719737932782711473526185314327429706123721184018526164843912357084299581282557834163087608711523332347
c= 5828665400659662200481257930448613556912466910028956416895009188678100386909653995901581798487196584505517205949477328949345164785085371759915602140665709476035759574131593907109076145868032864371280370522203844144419776437591517664380473995578020314238965796218842644269796377723374581784493311777190447527242501253991041432494385703487691181794563818370500886751504929179220588826849420285343147821037482564796404164142663325747444406331049194310027524244880507475966635549298077469138065853223611959428410417167179003219721139011717726446618184075004185716283850052481127065919476796414949852415947884586083184078
beta=0.33
delta=0.03
X=int(pow(N,delta))
Y=int(pow(N,delta+beta))
L=[]
L.append([N^2*X^3,0,0,0])
L.append([N*e*X^3,-N*X^2*Y,0,0])
L.append([e^2*X^3,-2*e*X^2*Y,X*Y^2,0])
L.append([e^3*X^3,-3*e^2*X^2*Y,3*e*X*Y^2,-Y^3])
L=Matrix(ZZ,L)
L=L.LLL()[0]
coeff=[]
coeff.append(L[0]//X^3)
coeff.append(L[1]//(X^2*Y))
coeff.append(L[2]//(X*Y^2))
coeff.append(L[3]//Y^3)
Z.<x,y>=ZZ[]
f=x^3*coeff[0]+x^2*y*coeff[1]+x*y^2*coeff[2]+y^3*coeff[3]
print(f.factor())
k=122758960842955082490723707195925090944931549808439871677978126142734379357232922577358494346844311129023301388856174022612131514572616596105520320029003691525127390354450939979945892746499060657659903732377453304871599184
dp=1558903319255880605
p=(e*dp-1)//k+1
q=N//p
phi=(p-1)*(q-1)
d=gmpy2.invert(e,phi)
m=pow(c,d,N)
print(bytes.fromhex(hex(m)[2:]))
```

